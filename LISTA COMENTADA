#include<stdio.h>

// Define a estrutura de um "Nó" da lista.
// Cada nó contém um valor inteiro e um ponteiro para o próximo nó.
struct Node {

    int value;    // O dado armazenado no nó
    Node *next;   // Ponteiro para o próximo nó na sequência

    // Construtor que inicializa o nó com um valor e aponta 'next' para NULL.
    Node(int _value) {
        value = _value;
        next = NULL;
    }

    // Construtor padrão que apenas inicializa 'next' como NULL.
    Node() {
        next = NULL;
    }

};

// Define a estrutura da "Lista", que gerencia os nós.
struct List {

    Node *start; // Ponteiro que aponta para o primeiro nó da lista.
    Node *end;   // Ponteiro que aponta para o último nó da lista.
    int c;       // Contador que armazena o número total de elementos.

    // Construtor da lista: inicializa uma lista vazia.
    List() {
        start = NULL;
        end = NULL;
        c = 0;
    }

    // Retorna 'true' se a lista estiver vazia (start == NULL).
    bool empty() {
        return start == NULL;
    }

    // Adiciona um novo elemento no FINAL da lista. (Complexidade: O(1))
    void pushBack(int value) {

        Node *n = new Node(value);
        c++;

        if (empty()) { // Se a lista estiver vazia, o novo nó é o início e o fim.
            start = n;
            end = n;
            return;
        }

        // Se não, o antigo último nó aponta para o novo, que se torna o fim.
        end->next = n;
        end = n;
    }

    // Adiciona um novo elemento no INÍCIO da lista. (Complexidade: O(1))
    void pushFront(int value) {

        Node *n = new Node(value);
        c++;

        if (empty()) { // Se a lista estiver vazia, o novo nó é o início e o fim.
            start = n;
            end = n;
            return;
        }

        // Se não, o novo nó aponta para o antigo início, e se torna o novo início.
        n->next = start;
        start = n;
    }

    // Imprime todos os elementos da lista, do início ao fim.
    void print() {
        Node *aux = start;
        while (aux != NULL) {
            printf("%d -> ", aux->value);
            aux = aux->next;
        }
        printf("\n");
    }

    // Retorna a quantidade de elementos na lista. (Complexidade: O(1))
    // Usar o contador 'c' é muito mais eficiente que percorrer a lista para contar.
    int size() {
        return c;
    }

    // Remove o primeiro elemento da lista. (Complexidade: O(1))
    void popFront() {
        if (empty()) return;

        c--;

        // Caso especial: se houver apenas um elemento.
        if (start == end) {
            delete(start);
            start = NULL;
            end = NULL;
            return;
        }

        // Caso geral: guarda o primeiro, avança o 'start' para o segundo e deleta o antigo.
        Node *aux = start;
        start = start->next;
        delete(aux);
    }

    // Remove o último elemento da lista. (Complexidade: O(n))
    // Precisa percorrer a lista para encontrar o PENÚLTIMO elemento.
    void popBack() {
        if (empty()) return;

        c--;

        // Caso especial: se houver apenas um elemento.
        if (start == end) {
            delete(start);
            start = NULL;
            end = NULL;
            return;
        }

        // Percorre a lista até achar o nó ANTERIOR ao 'end'.
        Node *newEnd = start;
        while (newEnd->next != end) {
            newEnd = newEnd->next;
        }

        // Deleta o último nó e atualiza o 'end' para ser o penúltimo.
        delete(end);
        end = newEnd;
        end->next = NULL;
    }

    // ATIVIDADE 1: Remove 'x' elementos do final da lista. (Complexidade: O(x * n))
    void atividade1(int x) {
        for (int i = 0; i < x; i++) {
            popBack();
        }
    }

    // ATIVIDADE 2: Remove o SEGUNDO elemento da lista. (Complexidade: O(1))
    void atividade2() {
        if (size() <= 1) return;
        if (size() == 2) {
            popBack();
            return;
        }

        Node* second = start->next;
        start->next = second->next; // O primeiro nó "pula" o segundo.
        delete(second);
        c--;
    }

    // ATIVIDADE 3: Adiciona o tamanho atual da lista como um novo elemento no final. (Complexidade: O(1))
    void atividade3() {
        pushBack(size());
    }

    // ATIVIDADE 4: Adiciona números de 1 a 'n' no final da lista. (Complexidade: O(n))
    void atividade4(int n) {
        for (int i = 1; i <= n; i++) {
            pushBack(i);
        }
    }

    // ATIVIDADE 5: Insere um valor 'x' antes do último elemento. (Complexidade: O(n))
    void atividade5(int x) {
        if (size() <= 1) return;

        // Encontra o penúltimo elemento.
        Node* aux = start;
        while (aux->next != end) {
            aux = aux->next;
        }
        
        // Insere o novo nó entre o penúltimo e o último.
        Node* n = new Node(x);
        n->next = end;
        aux->next = n;
        c++;
    }

    // Insere um elemento 'x' em uma posição 'pos' qualquer. (Complexidade: O(pos))
    void insert(int x, int pos) {
        if (pos <= 0) { // Se a posição for 0 ou negativa, insere no início.
            pushFront(x);
            return;
        }
        if (pos >= size()){ // Se a posição for maior que o tamanho, insere no fim.
            pushBack(x);
            return;
        }

        // Percorre a lista até a posição ANTERIOR à de inserção.
        Node* aux = start;
        for (int i = 0; i < pos - 1; i++) {
            aux = aux->next;
        }

        // Cria o novo nó e ajusta os ponteiros para encaixá-lo na lista.
        Node* n = new Node(x);
        n->next = aux->next;
        aux->next = n;
        c++;
    }

    // (Reimplementação da ATIVIDADE 5 usando a função 'insert')
    // Insere 'x' na penúltima posição. (Complexidade: O(n))
    void atividade5_nova(int x) {
        if (size() <= 1) return;
        insert(x, size() - 1);
    }
    
    // Remove um elemento de uma posição 'pos' qualquer. (Complexidade: O(pos))
    void remove(int pos) {
        if (pos <= 0) { // Se a posição for 0, remove do início.
            popFront();
            return;
        }
        if (pos >= size() - 1) { // Se for a última posição, remove do fim.
            popBack();
            return;
        }

        // Vai até o elemento ANTERIOR ao que será removido.
        Node* aux = start;
        for (int i = 0; i < pos - 1; i++) {
            aux = aux->next;
        }

        // Guarda o nó a ser removido, "pula" ele na lista e o deleta.
        Node* toDel = aux->next;
        aux->next = toDel->next;
        delete(toDel);
        c--;
    }

    // (Reimplementação da ATIVIDADE 2 usando a função 'remove')
    // Remove o segundo elemento (posição 1). (Complexidade: O(1))
    void atividade2_nova() {
        if (size() <= 1) return;
        remove(1);
    }

};

int main() {
    
    // 1. Cria uma lista vazia.
    List l;

    // 2. Executa uma série de operações para popular e modificar a lista.
    l.pushFront(10);
    l.pushFront(3);
    l.pushBack(5);
    l.pushBack(3);
    l.popFront();
    l.pushFront(8);
    l.pushBack(50);
    l.popBack();
    l.pushFront(78);
    l.pushBack(1);
    l.popBack();
    l.pushBack(75);
    l.pushFront(25);
    l.popFront();
    l.pushBack(60);
    l.popBack();
    l.pushFront(34);
    l.pushBack(80);
    l.pushBack(30);
    l.popFront();
    l.pushBack(23);
    l.popFront();
    l.popBack();
    l.pushFront(5);
    l.pushFront(66);
    l.popFront();

    // 3. Insere o valor 4 na posição 4 e o valor 100 na posição 8.
    l.insert(4, 4);
    l.insert(100, 8);

    // 4. Remove os elementos das posições 6 e 3.
    l.remove(6);
    l.remove(3);

    // 5. Imprime o estado final da lista na tela.
    l.print();

    return 0;
}
